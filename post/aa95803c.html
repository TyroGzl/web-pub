<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link href="https://fonts.proxy.ustclug.org/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="SummerSong"><meta name="keywords" content=""><meta name="description" content="《跟我一起写Makefile》是陈皓发表在其CSDN博客上的系列文章。该系列文章翻译整理自GNU Make Manual，一直受到读者的推荐，是很多人学习Makefile的首选文档。本文重新整理了一下，加入了代码高亮、颜色标记等。"><meta property="og:type" content="article"><meta property="og:title" content="（八）《跟我一起写Makefile》之使用函数"><meta property="og:url" content="https://summersong.top/post/aa95803c.html"><meta property="og:site_name" content="SummerSong&#39;s blog"><meta property="og:description" content="《跟我一起写Makefile》是陈皓发表在其CSDN博客上的系列文章。该系列文章翻译整理自GNU Make Manual，一直受到读者的推荐，是很多人学习Makefile的首选文档。本文重新整理了一下，加入了代码高亮、颜色标记等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://summersong.top/img/mf7.jpg"><meta property="article:published_time" content="2023-03-26T11:17:59.000Z"><meta property="article:modified_time" content="2024-03-29T02:20:58.501Z"><meta property="article:author" content="SummerSong"><meta property="article:tag" content="Makefile"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://summersong.top/img/mf7.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>（八）《跟我一起写Makefile》之使用函数 - SummerSong&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css# 滚动条颜色.css"><link rel="stylesheet" href="/css/mac.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3708452_waanfcf6zlk.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"summersong.top",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!0,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"iolF4oq16JCCrJAEqnYreWzQ-gzGzoHsz",app_key:"ux58hWuT3fEw0vvN55DjTgUe",server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>SummerSong&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="（八）《跟我一起写Makefile》之使用函数"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> SummerSong </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-03-26 19:17" pubdate>2023年3月26日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 75 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">（八）《跟我一起写Makefile》之使用函数</h1><p class="note note-info">本文最后更新于：2024年3月29日 上午</p><div class="markdown-body"><h1>使用函数</h1><p>在 Makefile 中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p><h2 id="函数的调用语法">函数的调用语法</h2><p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$(&lt;function&gt; &lt;arguments&gt;)<br></code></pre></td></tr></table></figure><p>或是:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;<br></code></pre></td></tr></table></figure><p>这里， <code>&lt;function&gt;</code> 就是函数名，make 支持的函数不多。 <code>&lt;arguments&gt;</code> 为函数的参数，参数间以逗号 <code>,</code> 分隔，而函数名和参数之间以“空格”分隔。函数调用以 <code>$</code> 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 <code>$(subst a,b,$(x))</code> 这样的形式，而不是 <code>$(subst a,b, $&#123;x&#125;)</code> 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p><p>还是来看一个示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">comma:= ,<br>empty:=<br>space:= <span class="hljs-variable">$(empty)</span> <span class="hljs-variable">$(empty)</span><br>foo:= a b c<br>bar:= <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> <span class="hljs-variable">$(space)</span>,<span class="hljs-variable">$(comma)</span>,<span class="hljs-variable">$(foo)</span>)</span><br></code></pre></td></tr></table></figure><p>在这个示例中， <code>$(comma)</code> 的值是一个逗号。 <code>$(space)</code> 使用了 <code>$(empty)</code> 定义了一个空格， <code>$(foo)</code> 的值是 <code>a b c</code>，<code>$(bar)</code> 的定义，调用了函数 <code>subst</code>，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把 <code>$(foo)</code> 中的空格替换成逗号，所以 <code>$(bar)</code> 的值是 <code>a,b,c</code>。</p><h2 id="字符串处理函数">字符串处理函数</h2><h3 id="subst">subst</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：字符串替换函数</li><li>功能：把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换成 <code>&lt;to&gt;</code> 。</li><li>返回：函数返回被替换过后的字符串。</li></ul><div class="note note-info"><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> ee,EE,feet on the street)</span><br></code></pre></td></tr></table></figure><p>把 <code>feet on the street</code> 中的 <code>ee</code> 替换成 <code>EE</code>，返回结果是 <code>fEEt on the strEEt</code>。</p></div><h3 id="patsubst">patsubst</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：模式字符串替换函数。</li><li>功能：查找 <code>&lt;text&gt;</code> 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 <code>&lt;pattern&gt;</code>，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里，<code>&lt;pattern&gt;</code> 可以包括通配符 <code>%</code>，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code>，那么，<code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串。（可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符）</li><li>返回：函数返回被替换过后的字符串。</li></ul><div class="note note-info"><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span><br></code></pre></td></tr></table></figure><p>把字串 <code>x.c.c bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o bar.o</code>。</p></div><div class="note note-success"><p>备注：这和我们前面“变量章节”说过的相关知识有点相似。如 <code>$(var:&lt;pattern&gt;=&lt;replacement&gt;;)</code> 相当于 <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code> ，而 <code>$(var: &lt;suffix&gt;=&lt;replacement&gt;)</code> 则相当于 <code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code> 。</p><p>例如有:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o baz.o<br></code></pre></td></tr></table></figure><p>那么， <code>$(objects:.o=.c)</code> 和 <code>$(patsubst %.o,%.c,$(objects))</code> 是一样的。</p></div><h3 id="strip">strip</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> &lt;string&gt;)</span><br></code></pre></td></tr></table></figure><ul><li><p>名称：去空格函数。</p></li><li><p>功能：去掉 <code>&lt;string&gt;</code> 字串中开头和结尾的空字符。</p></li><li><p>返回：返回被去掉空格的字符串值。</p></li></ul><div class="note note-info"><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> a b c )</span><br></code></pre></td></tr></table></figure><p>把字串 <code>a b c</code> 去掉开头和结尾的空格，结果是 <code>a b c</code>。</p></div><h3 id="findstring">findstring</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span><br></code></pre></td></tr></table></figure><ul><li><p>名称：查找字符串函数</p></li><li><p>功能：在字串 <code>&lt;in&gt;</code> 中查找 <code>&lt;find&gt;</code> 字串。</p></li><li><p>返回：如果找到，那么返回 <code>&lt;find&gt;</code>，否则返回空字符串。</p></li></ul><div class="note note-info"><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> a,a b c)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> a,b c)</span><br></code></pre></td></tr></table></figure><p>第一个函数返回 <code>a</code> 字符串，第二个返回空字符串</p></div><h3 id="filter">filter</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li><p>名称：过滤函数</p></li><li><p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</p></li><li><p>返回：返回符合模式 <code>&lt;pattern&gt;</code> 的字串。</p></li></ul><div class="note note-info"><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">sources := foo.c bar.c baz.s ugh.h<br><span class="hljs-section">foo: <span class="hljs-variable">$(sources)</span></span><br>	cc <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.c %.s,<span class="hljs-variable">$(sources)</span>)</span> -o foo<br></code></pre></td></tr></table></figure><p><code>$(filter %.c %.s,$(sources))</code> 返回的值是 <code>foo.c bar.c baz.s</code>。</p></div><h3 id="filter-out">filter-out</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li><p>名称：反过滤函数</p></li><li><p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，去除符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</p></li><li><p>返回：返回不符合模式 <code>&lt;pattern&gt;</code> 的字串。</p></li></ul><div class="note note-info"><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects=main1.o foo.o main2.o bar.o<br>mains=main1.o main2.o<br></code></pre></td></tr></table></figure><p><code>$(filter-out $(mains),$(objects))</code> 返回值是 <code>foo.o bar.o</code>。</p></div><h3 id="sort">sort</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> &lt;list&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：排序函数</li><li>功能：给字符串 <code>&lt;list&gt;</code> 中的单词排序（升序）。</li><li>返回：返回排序后的字符串。</li></ul><div class="note note-info"><p>示例： <code>$(sort foo bar lose)</code> 返回 <code>bar foo lose</code>。</p></div><div class="note note-warning"><p>备注： <code>sort</code> 函数会去掉 <code>&lt;list&gt;</code> 中相同的单词。</p></div><h3 id="word">word</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：取单词函数</li><li>功能：取字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。（从一开始）</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。如果 <code>&lt;n&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。</li></ul><div class="note note-info"><p>示例： <code>$(word 2, foo bar baz)</code> 返回值是 <code>bar</code>。</p></div><h3 id="wordlist">wordlist</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：取单词串函数</li><li>功能：从字符串 <code>&lt;text&gt;</code> 中取从 <code>&lt;ss&gt;</code> 开始到 <code>&lt;e&gt;</code> 的单词串。 <code>&lt;ss&gt;</code> 和 <code>&lt;e&gt;</code> 是一个数字。</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 中从 <code>&lt;ss&gt;</code> 到 <code>&lt;e&gt;</code> 的单词字串。如果 <code>&lt;ss&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数，那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的单词串。</li></ul><div class="note note-info"><p>示例： <code>$(wordlist 2, 3, foo bar baz)</code> 返回值是 <code>bar baz</code>。</p></div><h3 id="words">words</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(words &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：单词个数统计函数</li><li>功能：统计 <code>&lt;text&gt;</code> 中字符串中的单词个数。</li><li>返回：返回 <code>&lt;text&gt;</code> 中的单词数。</li></ul><div class="note note-info"><p>示例： <code>$(words, foo bar baz)</code> 返回值是 <code>3</code>。</p></div><div class="note note-success"><p>备注：如果我们要取 <code>&lt;text&gt;</code> 中最后的一个单词，我们可以这样： <code>$(word $(words &lt;text&gt;),&lt;text&gt;)</code>。</p></div><h3 id="firstword">firstword</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：首单词函数。</li><li>功能：取字符串 <code>&lt;text&gt;</code> 中的第一个单词。</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 的第一个单词。</li></ul><div class="note note-info"><p>示例： <code>$(firstword foo bar)</code> 返回值是 <code>foo</code>。</p></div><div class="note note-info"><p>备注：这个函数可以用 <code>word</code> 函数来实现： <code>$(word 1,&lt;text&gt;)</code>。</p></div><p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make 使用 <code>VPATH</code> 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 <code>CFLAGS</code>，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> CFLAGS += <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %,-I%,$(<span class="hljs-built_in">subst</span> :, ,<span class="hljs-variable">$(VPATH)</span>)</span>)<br></code></pre></td></tr></table></figure><p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers</code>，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code>，这正是 cc 或 gcc 搜索头文件路径的参数。</p><h2 id="文件名操作函数">文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p><h3 id="dir">dir</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：取目录函数。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出目录部分。目录部分是指最后一个反斜杠（<code>/</code>）之前的部分。如果没有反斜杠，那么返回 <code>./</code>。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的目录部分。</li></ul><div class="note note-info"><p>示例： <code>$(dir src/foo.c hacks)</code> 返回值是 <code>src/ ./</code>。</p></div><h3 id="notdir">notdir</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：取文件函数。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出非目录部分。非目录部分是指最后一个反斜杠（<code>/</code>）之后的部分。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的非目录部分。</li></ul><div class="note note-info"><p>示例: <code>$(notdir src/foo.c hacks)</code> 返回值是 <code>foo.c hacks</code>。</p></div><h3 id="suffix">suffix</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：取后缀函数。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的后缀。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的后缀序列，如果文件没有后缀，则返回空字串。</li></ul><div class="note note-info"><p>示例： <code>$(suffix src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>.c .c</code>。</p></div><h3 id="basename">basename</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：取前缀函数。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的前缀部分。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的前缀序列，如果文件没有前缀，则返回空字串。</li></ul><div class="note note-info"><p>示例： <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>src/foo src-1.0/bar hacks</code>。</p></div><h3 id="addsuffix">addsuffix</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> &lt;<span class="hljs-built_in">suffix</span>&gt;,&lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：加后缀函数。</li><li>功能：把后缀 <code>&lt;suffix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</li><li>返回：返回加过后缀的文件名序列。</li></ul><div class="note note-info"><p>示例： <code>$(addsuffix .c,foo bar)</code> 返回值是 <code>foo.c bar.c</code>。</p></div><h3 id="addprefix">addprefix</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：加前缀函数。</li><li>功能：把前缀 <code>&lt;prefix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词前面。</li><li>返回：返回加过前缀的文件名序列。</li></ul><div class="note note-info"><p>示例： <code>$(addprefix src/,foo bar)</code> 返回值是 <code>src/foo src/bar</code>。</p></div><h3 id="join">join</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span><br></code></pre></td></tr></table></figure><ul><li>名称：连接函数。</li><li>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中。</li><li>返回：返回连接过后的字符串。</li></ul><div class="note note-info"><p>示例： <code>$(join aaa bbb , 111 222 333)</code> 返回值是 <code>aaa111 bbb222 333</code>。</p></div><h2 id="foreach-函数">foreach 函数</h2><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile 中的 foreach 函数几乎是仿照于 Unix标准 Shell（/bin/sh）中的 for 语句，或是 C-Shell（/bin/csh）中的 foreach 语句而构建的。它的语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>这个函数的意思是，把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code> 所指定的变量中，然后再执行 <code>&lt;text&gt;</code> 所包含的表达式。每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中， <code>&lt;text&gt;</code> 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， <code>&lt;text&gt;</code> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。</p><p>所以， <code>&lt;var&gt;</code> 最好是一个变量名，<code>&lt;list&gt;</code> 可以是一个表达式，而 <code>&lt;text&gt;</code> 中一般会使用 <code>&lt;var&gt;</code> 这个参数来依次枚举 <code>&lt;list&gt;</code> 中的单词。举个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">names := a b c d<br><br>files := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> n,<span class="hljs-variable">$(names)</span>,<span class="hljs-variable">$(n)</span>.o)</span><br></code></pre></td></tr></table></figure><p>上面的例子中， <code>$(name)</code> 中的单词会被挨个取出，并存到变量 <code>n</code> 中，<code>$(n).o</code> 每次根据 <code>$(n)</code> 计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回，所以，<code>$(files)</code> 的值是 <code>a.o b.o c.o d.o</code>。</p><p>注意，foreach 中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach 函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用，其作用域只在 foreach 函数当中。</p><h2 id="if-函数">if 函数</h2><p>if 函数很像 GNU 的 make 所支持的条件语句——<code>ifeq</code>（参见前面所述的章节），if 函数的语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span><br></code></pre></td></tr></table></figure><p>或是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span><br></code></pre></td></tr></table></figure><p>可见，if 函数可以包含“else”部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。 <code>&lt;condition&gt;</code> 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， <code>&lt;then-part&gt;</code> 会被计算，否则 <code>&lt;else-part&gt;</code> 会被计算。</p><p>而 if 函数的返回值是，如果 <code>&lt;condition&gt;</code> 为真（非空字符串），那个 <code>&lt;then-part&gt;</code> 会是整个函数的返回值，如果 <code>&lt;condition&gt;</code> 为假（空字符串），那么 <code>&lt;else-part&gt;</code> 会是整个函数的返回值，此时如果 <code>&lt;else-part&gt;</code> 没有被定义，那么，整个函数返回空字串。</p><p>所以， <code>&lt;then-part&gt;</code> 和 <code>&lt;else-part&gt;</code> 只会有一个被计算。</p><h2 id="call函数">call函数</h2><p>call 函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以 call 函数来向这个表达式传递参数。其语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</span><br></code></pre></td></tr></table></figure><p>当 make 执行这个函数时， <code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、 <code>$(2)</code> 等，会被参数 <code>&lt;parm1&gt;</code>、<code>&lt;parm2&gt;</code>、<code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的返回值就是 call 函数的返回值。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">reverse =  $(1) $(2)<br><br>foo = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> reverse,a,b)</span><br></code></pre></td></tr></table></figure><p>那么， <code>foo</code> 的值就是 <code>a b</code> 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">reverse =  $(2) $(1)<br><br>foo = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> reverse,a,b)</span><br></code></pre></td></tr></table></figure><p>此时的 <code>foo</code> 的值就是 <code>b a</code>。</p><div class="note note-warning"><p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第 2 个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格。</p></div><h2 id="origin函数">origin函数</h2><p>origin 函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">origin</span> &lt;variable&gt;)</span><br></code></pre></td></tr></table></figure><p>注意， <code>&lt;variable&gt;</code> 是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code> 中使用</p><p><code>$</code> 字符。Origin 函数会以其返回值来告诉你这个变量的“出生情况”，下面，是 origin 函数的返回值:</p><ul><li><p><code>undefined</code></p><p>如果 <code>&lt;variable&gt;</code> 从来没有定义过，origin 函数返回这个值 <code>undefined</code></p></li><li><p><code>default</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p></li><li><p><code>environment</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个环境变量，并且当 Makefile 被执行时， <code>-e</code> 参数没有被打开。</p></li><li><p><code>file</code></p><p>如果 <code>&lt;variable&gt;</code> 这个变量被定义在 Makefile 中。</p></li><li><p><code>command line</code></p><p>如果 <code>&lt;variable&gt;</code> 这个变量是被命令行定义的。</p></li><li><p><code>override</code></p><p>如果 <code>&lt;variable&gt;</code> 是被 override 指示符重新定义的。</p></li><li><p><code>automatic</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p></li></ul><p>这些信息对于我们编写 Makefile 是非常有用的，例如，假设我们有一个 Makefile 其包了一个定义文件 Make.def，在 Make.def 中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于 Make.def 或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> bletch<br>	<span class="hljs-keyword">ifeq</span> <span class="hljs-string">&quot;$(origin bletch)&quot;</span> <span class="hljs-string">&quot;environment&quot;</span><br>		bletch = barf, gag, etc.<br>	<span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>当然，你也许会说，使用 <code>override</code> 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 <code>override</code> 是可以达到这样的效果，可是 <code>override</code> 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p><h2 id="shell函数">shell函数</h2><p>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统 Shell 的命令。它和反引号是相同的功能。这就是说，shell 函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令 awk，sed 等等命令来生成一个变量，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> cat foo)</span><br>files := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo *.c)</span><br></code></pre></td></tr></table></figure><p>注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的 Makefile 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 Makefile 的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。</p><h2 id="控制-make-的函数">控制 make 的函数</h2><p>make 提供了一些函数来控制 make 的运行。通常，你需要检测一些运行 Makefile 时的运行时信息，并且根据这些信息来决定，你是让 make 继续执行，还是停止。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> &lt;text ...&gt;)</span><br></code></pre></td></tr></table></figure><p>产生一个致命的错误，<code>&lt;text ...&gt;</code> 是错误信息。注意，error 函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p><p>示例一：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> ERROR_001<br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> <span class="hljs-built_in">error</span> is <span class="hljs-variable">$(ERROR_001)</span>)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ERR = <span class="hljs-variable">$(<span class="hljs-built_in">error</span> found an <span class="hljs-built_in">error</span>!)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: err</span><br><br><span class="hljs-section">err: <span class="hljs-variable">$(ERR)</span></span><br></code></pre></td></tr></table></figure><p>示例一会在变量 ERROR_001 定义了后执行时产生 error 调用，而示例二则在目录 err 被执行时才发生 error 调用。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> &lt;text ...&gt;)</span><br></code></pre></td></tr></table></figure><p>这个函数很像 error 函数，只是它并不会让 make 退出，只是输出一段警告信息，而 make 继续执行。</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/haoel/article/details/2894?ops_request_misc=%7B%22request%5Fid%22%3A%22167996671416800184184025%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=167996671416800184184025&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-14-2894-null-null.blog_rank_default&amp;utm_term=makefile&amp;spm=1018.2226.3001.4450">跟我一起写 Makefile（九）_haoel的博客-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/haoel/article/details/2895?ops_request_misc=%7B%22request%5Fid%22%3A%22167996671416800184184025%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=167996671416800184184025&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-2895-null-null.blog_rank_default&amp;utm_term=makefile&amp;spm=1018.2226.3001.4450">跟我一起写 Makefile（十）_haoel的博客-CSDN博客</a></p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Makefile/" class="category-chain-item">Makefile</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Makefile/">#Makefile</a></div></div><div class="license-box my-3"><div class="license-title"><div>（八）《跟我一起写Makefile》之使用函数</div><div>https://summersong.top/post/aa95803c.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>SummerSong</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年3月26日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月29日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/post/db37f9eb.html" title="（九）《跟我一起写Makefile》之make的运行"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">（九）《跟我一起写Makefile》之make的运行</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/ad67fc2d.html" title="（七）《跟我一起写Makefile》之使用条件判断"><span class="hidden-mobile">（七）《跟我一起写Makefile》之使用条件判断</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/dianjichuzi.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>