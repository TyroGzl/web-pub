<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link href="https://fonts.proxy.ustclug.org/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="SummerSong"><meta name="keywords" content=""><meta name="description" content="《跟我一起写Makefile》是陈皓发表在其CSDN博客上的系列文章。该系列文章翻译整理自GNU Make Manual，一直受到读者的推荐，是很多人学习Makefile的首选文档。本文重新整理了一下，加入了代码高亮、颜色标记等。"><meta property="og:type" content="article"><meta property="og:title" content="《跟我一起写Makefile》之书写规则"><meta property="og:url" content="https://summersong.top/post/906f2872.html"><meta property="og:site_name" content="SummerSong&#39;s blog"><meta property="og:description" content="《跟我一起写Makefile》是陈皓发表在其CSDN博客上的系列文章。该系列文章翻译整理自GNU Make Manual，一直受到读者的推荐，是很多人学习Makefile的首选文档。本文重新整理了一下，加入了代码高亮、颜色标记等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://summersong.top/img/mf3.jpg"><meta property="article:published_time" content="2023-03-25T05:43:07.000Z"><meta property="article:modified_time" content="2023-03-25T06:07:18.773Z"><meta property="article:author" content="SummerSong"><meta property="article:tag" content="Makefile"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://summersong.top/img/mf3.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>《跟我一起写Makefile》之书写规则 - SummerSong&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css# 滚动条颜色.css"><link rel="stylesheet" href="/css/mac.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3708452_waanfcf6zlk.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"summersong.top",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!0,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"iolF4oq16JCCrJAEqnYreWzQ-gzGzoHsz",app_key:"ux58hWuT3fEw0vvN55DjTgUe",server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>SummerSong&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="《跟我一起写Makefile》之书写规则"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> SummerSong </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-03-25 13:43" pubdate>2023年3月25日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 70 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">《跟我一起写Makefile》之书写规则</h1><p class="note note-info">本文最后更新于：2023年3月25日 下午</p><div class="markdown-body"><h1>书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p><p>在 Makefile 中，规则的顺序是很重要的，因为，Makefile 中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make 知道你的最终目标是什么。一般来说，定义在 Makefile 中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make 所完成的也就是这个目标。</p><p>好了，还是让我们来看一看如何书写规则。</p><h2 id="规则举例">规则举例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo.o : foo.c defs.h       <span class="hljs-comment"># foo模块</span><br>	cc -c -g foo.c<br></code></pre></td></tr></table></figure><p>看到这个例子，各位应该不是很陌生了，前面也已说过， <code>foo.o</code> 是我们的目标，<code>foo.c</code> 和 <code>defs.h</code> 是目标所依赖的源文件，而只有一个命令 <code>cc -c -g foo.c</code>（以 Tab 键开头）。这个规则告诉我们两件事：</p><ol><li>文件的依赖关系， <code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>defs.h</code> 的文件，如果 <code>foo.c</code> 和 <code>defs.h</code> 的文件日期要比 <code>foo.o</code> 文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖关系发生。</li><li>如何生成或更新 <code>foo.o</code> 文件，就是那个 <code>cc</code> 命令。它说明了如何生成 <code>foo.o</code> 这个文件。（当然，<code>foo.c</code> 文件 include 了 <code>defs.h</code> 文件）</li></ol><h2 id="规则的语法">规则的语法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets : prerequisites<br>	command<br>	...<br></code></pre></td></tr></table></figure><p>或是这样：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets : prerequisites ; command<br>	command<br>	...<br></code></pre></td></tr></table></figure><p>targets 是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p><p>command 是命令行，如果其不与 <code>target : prerequisites</code> 在一行，那么，必须以 <code>Tab</code> 键开头，如果和 prerequisites 在一行，那么可以用分号做为分隔。（见上）</p><p>prerequisites 也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。</p><p>如果命令太长，你可以使用反斜杠（<code>\</code>）作为换行符。make 对一行上有多少个字符没有限制。规则告诉 make 两件事，文件的依赖关系和如何生成目标文件。</p><p>一般来说，make 会以 UNIX 的标准 Shell，也就是 <code>/bin/sh</code> 来执行命令。</p><h2 id="在规则中使用通配符">在规则中使用通配符</h2><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make 支持三个通配符：<code>*</code>，<code>?</code> 和 <code>~</code>。这是和 Unix 的 B-Shell 是相同的。</p><p>波浪号（<code>~</code>）字符在文件名中也有比较特殊的用途。如果是 <code>~/test</code>，这就表示当前用户的 <code>$HOME</code> 目录下的 test 目录。而 <code>~hchen/test</code> 则表示用户 <code>hchen</code> 的宿主目录下的 test 目录。（这些都是 Unix 下的小知识了，make 也支持）而在 Windows 或是 MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。</p><p>通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为 c 的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：<code>*</code>，那么可以用转义字符 <code>\</code>，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。</p><p>好吧，还是先来看几个例子吧：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>	rm -f *.o<br></code></pre></td></tr></table></figure><p>上面这个例子我不多说了，这是操作系统 Shell 所支持的通配符。</p><p>这是在命令中的通配符：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">print: *.c</span><br>	lpr -p <span class="hljs-variable">$?</span><br>	touch print<br></code></pre></td></tr></table></figure><p>上面这个例子说明了通配符也可以在我们的规则中，目标 <code>print</code> 依赖于所有的 <code>.c</code> 文件。其中的 <code>$?</code> 是一个自动化变量，我会在后面给你讲述。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = *.o<br></code></pre></td></tr></table></figure><p>上面这个例子，表示了通配符同样可以用在变量中。并不是说 <code>*.o</code> 会展开，不！objects 的值就是 <code>*.o</code>。Makefile 中的变量其实就是 C/C++ 中的宏。如果你要让通配符在变量中展开，也就是让 objects 的值是所有 <code>.o</code> 的文件名的集合，那么，你可以这样：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.o)</span><br></code></pre></td></tr></table></figure><p>另给一个变量使用通配符的例子：</p><ol><li><p>列出一确定文件夹中的所有 <code>.c</code> 文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br></code></pre></td></tr></table></figure></li><li><p>列出（1）中所有文件对应的 <code>.o</code> 文件，在（3）中我们可以看到它是由make 自动编译出的:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,$(<span class="hljs-built_in">wildcard</span> *.c)</span>)<br></code></pre></td></tr></table></figure></li><li><p>由（1）（2）两步，可写出编译并链接所有 <code>.c</code> 和 <code>.o</code> 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,$(<span class="hljs-built_in">wildcard</span> *.c)</span>)<br>foo : <span class="hljs-variable">$(objects)</span><br>	cc -o foo <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure></li></ol><p>这种用法由关键字 <code>wildcard</code>，<code>patsubst</code> 指出，关于 Makefile 的关键字，我们将在后面讨论。</p><h2 id="文件搜寻">文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当 make 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 make，让 make 自动去找。</p><p>Makefile 文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make 就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = src:../headers<br></code></pre></td></tr></table></figure><p>上面的定义指定两个目录，<code>src</code> 和 <code>../headers</code>，make 会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p><p>另一个设置文件搜索路径的方法是使用 make 的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个 make 的关键字，这和上面提到的那个 <code>VPATH</code> 变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p><ol><li><p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code></p><p>为符合模式 <code>&lt;pattern&gt;</code> 的文件指定搜索目录 <code>&lt;directories&gt;</code>。</p></li><li><p><code>vpath &lt;pattern&gt;</code></p><p>清除符合模式 <code>&lt;pattern&gt;</code> 的文件的搜索目录。</p></li><li><p><code>vpath</code></p><p>清除所有已被设置好了的文件搜索目录。</p></li></ol><p>vpath 使用方法中的<code>&lt;pattern&gt;</code>需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配零或若干字符，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<code>&lt;pattern&gt;</code> 指定了要搜索的文件集，而 <code>&lt;directories&gt;</code> 则指定了 <code>&lt;pattern&gt;</code> 的文件集的搜索的目录。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.h ../headers<br></code></pre></td></tr></table></figure><p>该语句表示，要求 make 在 <code>../headers</code> 目录下搜索所有以 <code>.h</code> 结尾的文件。（如果某文件在当前目录没有找到的话）</p><p>我们可以连续地使用 <code>vpath</code> 语句，以指定不同搜索策略。如果连续的 <code>vpath</code> 语句中出现了相同的 <code>&lt;pattern&gt;</code>，或是被重复了的 <code>&lt;pattern&gt;</code>，那么，make 会按照 <code>vpath</code> 语句的先后顺序来执行搜索。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c foo<br><span class="hljs-keyword">vpath</span> %   blish<br><span class="hljs-keyword">vpath</span> %.c bar<br></code></pre></td></tr></table></figure><p>其表示 <code>.c</code> 结尾的文件，先在 <code>foo</code> 目录，然后是 <code>blish</code>，最后是 <code>bar</code> 目录。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c foo:bar<br><span class="hljs-keyword">vpath</span> %   blish<br></code></pre></td></tr></table></figure><p>而上面的语句则表示 <code>.c</code> 结尾的文件，先在 <code>foo</code> 目录，然后是 <code>bar</code> 目录，最后才是 <code>blish</code> 目录。</p><h2 id="伪目标">伪目标</h2><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>	rm *.o temp<br></code></pre></td></tr></table></figure><p>正像我们前面例子中的“clean”一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以 <code>make clean</code> 来使用该目标）</p><p>因为，我们并不生成`clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显式地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : clean<br></code></pre></td></tr></table></figure><p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有 <code>make clean</code> 这样。于是整个过程可以这样写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : clean<br>clean :<br>	rm *.o temp<br></code></pre></td></tr></table></figure><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">all : prog1 prog2 prog3<br>.PHONY : all<br><br>prog1 : prog1.o utils.o<br>	cc -o prog1 prog1.o utils.o<br><br>prog2 : prog2.o<br>	cc -o prog2 prog2.o<br><br>prog3 : prog3.o sort.o utils.o<br>	cc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure><p>我们知道，Makefile 中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。</p><p><code>.PHONY : all</code> 声明了“all”这个目标为“伪目标”，伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。</p><div class="note note-info"><p>（注：这里的显式 <code>.PHONY : all</code> 不写的话一般情况也可以正确的执行，这样 make 可通过隐式规则推导出，“all” 是一个伪目标，执行 make 不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p></div><p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : cleanall cleanobj cleandiff<br><br>cleanall : cleanobj cleandiff<br>	rm program<br><br>cleanobj :<br>	rm *.o<br><br>cleandiff :<br>	rm *.diff<br></code></pre></td></tr></table></figure><p><code>make cleanall</code> 将清除所有要被清除的文件。<code>cleanobj</code> 和 <code>cleandiff</code> 这两个伪目标有点像“子程序”的意思。我们可以输入 <code>make cleanall</code> 和 <code>make cleanobj</code> 和 <code>make cleandiff</code> 命令来达到清除不同种类文件的目的。</p><h2 id="多目标">多目标</h2><p>Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 <code>$@</code>（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bigoutput littleoutput : text.g<br>	generate text.g -<span class="hljs-variable">$(<span class="hljs-built_in">subst</span> output,,<span class="hljs-variable">$@</span>)</span> &gt; <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>上述规则等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bigoutput : text.g<br>	generate text.g -big &gt; bigoutput<br>littleoutput : text.g<br>	generate text.g -little &gt; littleoutput<br></code></pre></td></tr></table></figure><p>其中， <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个 Makefile 的函数，函数名为 <code>subst</code>，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， <code>$@</code> 表示目标的集合，就像一个数组，<code>$@</code> 依次取出目标，并执于命令。</p><h2 id="静态模式">静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;<br>	&lt;commands&gt;<br>	...<br></code></pre></td></tr></table></figure><ul><li><p><strong>targets</strong>：定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p></li><li><p><strong>target-pattern</strong>：是指明了 targets 的模式，也就是目标集的模式。</p></li><li><p><strong>prereq-patterns</strong>：是目标的依赖模式，它对 target-pattern 形成的模式再进行一次依赖目标的定义。</p></li></ul><p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 <code>&lt;target-pattern&gt;</code> 定义成 <code>%.o</code>，意思是我们的 <code>&lt;target&gt;</code> 集合中都是以 <code>.o</code> 结尾的，而如果我们的 <code>&lt;prereq-patterns&gt;</code> 定义成 <code>%.c</code>，意思是对 <code>&lt;target-pattern&gt;</code> 所形成的目标集进行二次定义，其计算方法是，取 <code>&lt;target-pattern&gt;</code> 模式中的 <code>%</code>（也就是去掉了 <code>.o</code> 这个结尾），并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p><p>所以，我们的“目标模式”或是“依赖模式”中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。</p><p>看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>上面的例子中，指明了我们的目标从 <code>$object</code> 中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code>，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code>，也就是 <code>foo bar</code>，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code>。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件， <code>$@</code> 表示目标集（也就是 <code>foo.o bar.o</code>）。于是，上面的规则展开后等价于下面的规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo.o : foo.c<br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> foo.c -o foo.o<br>bar.o : bar.c<br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> bar.c -o bar.o<br></code></pre></td></tr></table></figure><p>试想，如果我们的 <code>%.o</code> 有几百个，那么我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = foo.elc bar.o lose.o<br><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o,<span class="hljs-variable">$(files)</span>)</span>: %.o: %.c<br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.elc,<span class="hljs-variable">$(files)</span>)</span>: %.elc: %.el<br>	emacs -f batch-byte-compile <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p><code>$(filter %.o,$(files))</code> 表示调用 Makefile 的 <code>filter</code> 函数，过滤 <code>$files</code> 集，只要其中模式为 <code>%.o</code> 的内容。其它的内容，我就不用多说了吧。这个例子展示了Makefile 中更大的弹性。</p><h2 id="自动生成依赖性">自动生成依赖性</h2><p>在 Makefile 中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的 <code>main.c</code> 中有一句 <code>#include &quot;defs.h&quot;</code> ，那么我们的依赖关系应该是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : main.c defs.h<br></code></pre></td></tr></table></figure><p>但是，如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 C/C++ 编译的一个功能。大多数的 C/C++ 编译器都支持一个 <code>-M</code> 的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc -M main.c<br></code></pre></td></tr></table></figure><p>其输出是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : main.c defs.h<br></code></pre></td></tr></table></figure><p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用 GNU 的 C/C++ 编译器，你得用 <code>-MM</code> 参数，不然， <code>-M</code> 参数会把一些标准库的头文件也包含进来。</p><p><code>gcc -M main.c</code> 的输出是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">main.o: main.c defs.h /usr/include/stdio.h \<br>		/usr/include/features.h \<br>    	/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \<br>    	/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \<br>	    /usr/include/bits/types.h \<br>        /usr/include/bits/pthreadtypes.h \<br>    	/usr/include/bits/sched.h /usr/include/libio.h \<br>    	/usr/include/_G_config.h /usr/include/wchar.h \<br>    	/usr/include/bits/wchar.h /usr/include/gconv.h \<br>    	/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \<br>    	/usr/include/bits/stdio_lim.h<br></code></pre></td></tr></table></figure><p><code>gcc -MM main.c</code> 的输出则是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">main.o: main.c defs.h<br></code></pre></td></tr></table></figure><p>那么，编译器的这个功能如何与我们的 Makefile 联系在一起呢。因为这样一来，我们的 Makefile 也要根据这些源文件重新生成，让 Makefile 自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的 Makefile 文件， <code>.d</code> 文件中就存放对应 <code>.c</code> 文件的依赖关系。</p><p>于是，我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让make自动更新或生成 <code>.d</code> 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p><p>这里，我们给出了一个模式规则来产生 <code>.d</code> 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%.d: %.c</span><br>	@set -e; rm -f <span class="hljs-variable">$@</span>; \<br>	<span class="hljs-variable">$(CC)</span> -M <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$&lt;</span> &gt; <span class="hljs-variable">$@</span>.$$$$; \<br>	sed &#x27;s,\(<span class="hljs-variable">$*</span>\)\.o[ :]*,\1.o <span class="hljs-variable">$@</span> : ,g&#x27; &lt; <span class="hljs-variable">$@</span>.$$$$ &gt; <span class="hljs-variable">$@</span>; \<br>	rm -f <span class="hljs-variable">$@</span>.$$$$<br></code></pre></td></tr></table></figure><p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件，<code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个 C 文件是 <code>name.c</code>，那么 <code>%</code> 就是 <code>name</code>，<code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是 <code>name.d.12345</code>，第三行使用 <code>sed</code> 命令做了一个替换，关于 <code>sed</code> 命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : main.c defs.h<br></code></pre></td></tr></table></figure><p>转成：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o main.d : main.c defs.h<br></code></pre></td></tr></table></figure><p>于是，我们的 <code>.d</code> 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 <code>.d</code> 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 <code>.d</code> 文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主 Makefile 中。我们可以使用 Makefile 的 <code>include</code> 命令，来引入别的 Makefile 文件（前面讲过），例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">sources = foo.c bar.c<br><br><span class="hljs-keyword">include</span> $(sources:.c=.d)<br></code></pre></td></tr></table></figure><p>上述语句中的 <code>$(sources:.c=.d)</code> 中的 <code>.c=.d</code> 的意思是做一个替换，把变量 <code>$(sources)</code> 所有 <code>.c</code> 的字串都替换成 <code>.d</code>，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为 <code>include</code> 是按次序来载入文件，最先载入的 <code>.d</code> 文件中的目标会成为默认目标。</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/haoel/article/details/2890?ops_request_misc=%7B%22request%5Fid%22%3A%22167971811116800215066554%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=167971811116800215066554&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-8-2890-null-null.blog_rank_default&amp;utm_term=makefile&amp;spm=1018.2226.3001.4450">跟我一起写 Makefile（五）_haoel的博客-CSDN博客</a></p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Makefile/" class="category-chain-item">Makefile</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Makefile/">#Makefile</a></div></div><div class="license-box my-3"><div class="license-title"><div>《跟我一起写Makefile》之书写规则</div><div>https://summersong.top/post/906f2872.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>SummerSong</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年3月25日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2023年3月25日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/post/227282b7.html" title="《跟我一起写Makefile》之书写命令"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">《跟我一起写Makefile》之书写命令</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/e5b5bdd8.html" title="《跟我一起写Makefile》之Makefile总述"><span class="hidden-mobile">《跟我一起写Makefile》之Makefile总述</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/dianjichuzi.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>